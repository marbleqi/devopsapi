# 代码尽量重用

- 使用面向切面编程模式，设计通用的路由守卫和拦截器
- 抽象通用的类和通用的方法

# 前后端分离

- 尽量减少前后端数据交互量
  - 数据列表请求接口增加版本标记，只返回版本标记变化后的数据
  - 规划返回数据格式的字段，只返回必要字段
- 尽量减少后端的处理压力
  - 后端不做返回数据的逻辑处理（排序，关联等）和格式转换，只讲必要的数据返回给前端，由前端基于这些数据做页面渲染

# 请求的处理逻辑

## 同步处理的内容（）

- 按需验证请求消息头中的令牌，如果验证不通过则抛出异常
- 根据请求路由验证令牌的有效性，如果验证不通过则抛出异常
- 验证请求提交数据的有效性，如果验证不通过则抛出异常
- 处理提交数据，并确定处理结果
- 处理结果：
  - 数据没有变化（判断依据是，保存后的返回值是否包括 updateAt 字段，如果没有，则说明数据一致，没有实际更新？）
  - 数据记录失败
  - 注：如果提交数据没有变化，也记录给数据变化（验证数据是否修改，由前端在提交前，进行数据校验）
- 返回响应消息

## 异步处理的内容

### 请求日志的处理

- 在路由守卫中，将请求数据保存到上下文中
- 在路由守卫中增加对请求的权限处理，如果权限不足，则触发日志生成事件，并直接返回异常
- 如果权限满足，则在控制器中，在上下文中保存响应数据
- 如果权限满足，则拦截器在控制器执行后，触发日志日志生成事件
- 在请求日志服务中处理日志事件，将请求日志记录到数据库中

### 实体对象日志的处理

- 如果请求是对实体对象的创建或修改，且操作成功，则需要记录实体对象日志。（如果操作如果不成功，则只记录请求日志）
- 获取对象操作的最新版本号（不同对象的版本号相互隔离，各自递增）
- 将对象操作的最新版本号保存到实体对象表中，并触发实体对象更新事件
- 配置实体对象更新事件处理逻辑，将最新的实体对象更新信息添加到实体对象日志表中

### 消息队列的作用

- 为了提交响应效率，部分重复使用且较少修改的数据直接加载到后端缓存中，但如果出现数据修改就需要所有后端副本都更新缓存数据
- 为了减少无效交互，部分重复使用且较少修改的数据直接缓存在前端中，如果出现数据更新，需要所有后端通知前端更新缓存数据

### 实体对象的处理逻辑
